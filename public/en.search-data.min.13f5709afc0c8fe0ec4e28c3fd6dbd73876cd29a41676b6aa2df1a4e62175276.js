'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/docs/example/',title:"Example Site",section:"Docs",content:"Introduction\r#\r\rA blog powered by hugo\r#\r\rLorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nFeatures\r#\r\r Clean simple design Light and Mobile-Friendly Multi-language support Customisable Zero initial configuration Handy shortcodes Comments support Simple blog and taxonomy Primary features work without JavaScript Dark Mode  Fortran\r#\r\rFortran is a general-purpose, compiled imperative programming language that is especially suited to numeric computation and scientific computing.\n! Cooley-Tukey FFT\rrecursive subroutine fft(x,sgn)\rimplicit none\rinteger, intent(in) :: sgn\rcomplex(8), dimension(:), intent(inout) :: x\rcomplex(8) :: t\rinteger :: N\rinteger :: i\rcomplex(8), dimension(:), allocatable :: even, odd\rN=size(x)\rif(N .le. 1) return\rallocate(odd((N+1)/2))\rallocate(even(N/2))\r! divide\rodd =x(1:N:2)\reven=x(2:N:2)\r! conquer\rcall fft(odd, sgn)\rcall fft(even, sgn)\r! combine\rdo i=1,N/2\rt=exp(cmplx(0.0d0,sgn*2.0d0*pi*(i-1)/N))*even(i)\rx(i) = odd(i) + t\rx(i+N/2) = odd(i) - t\rend do\rdeallocate(odd)\rdeallocate(even)\rend subroutine fft\r "}),a.add({id:1,href:'/docs/shortcodes/',title:"shortcodes",section:"Docs",content:"Buttons\r#\r\rButtons are styled links that can lead to local page or external link.\nExample\r#\r\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} \rGet Home\r\rContribute\r\rColumns\r#\r\rColumns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example\r#\r\rLeft Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r\rMid Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\r\rRight Content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r\r\rDetails\r#\r\rDetails shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample\r#\r\r{{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title\rMarkdown content Lorem markdownum insigne\u0026hellip;\r\r\rExpand\r#\r\rExpand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample\r#\r\rDefault\r#\r\r{{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} \r\rExpand\r↕\r\rMarkdown content Lorem markdownum insigne\u0026hellip;\r\r\r\rWith Custom Label\r#\r\r{{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} \r\rCustom Label\r...\r\rMarkdown content Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\r\r\r\rHints\r#\r\rHint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example\r#\r\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r\rKaTeX\r#\r\rKaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample\r#\r\r{{\u0026lt; katex [display] [class=\u0026#34;text-center\u0026#34;] \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}} \r\r\r\rDisplay Mode Example\r#\r\rHere is some inline example: \r\\(\\pi(x)\\)\r\r, rendered in the same line. And below is display example, having display: block \r\\[\rf(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\r\\]\r\rText continues here.\nMermaid Chart\r#\r\rMermaid is library for generating svg charts and diagrams from text.\nExample\r#\r\r{{\u0026lt; mermaid [class=\u0026#34;text-center\u0026#34;]\u0026gt;}} sequenceDiagram Alice-\u0026gt;\u0026gt;Bob: Hello Bob, how are you? alt is sick Bob-\u0026gt;\u0026gt;Alice: Not so good :( else is well Bob-\u0026gt;\u0026gt;Alice: Feeling fresh like a daisy end opt Extra response Bob-\u0026gt;\u0026gt;Alice: Thanks for asking end {{\u0026lt; /mermaid \u0026gt;}} \r\r\r\rTabs\r#\r\rTabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example\r#\r\rMacOS\rMacOS This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux\rLinux This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows\rWindows This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n\r"}),a.add({id:2,href:'/docs/code/go/go-function/',title:"go function",section:"Go",content:"方法声明\r#\r\r与声明普通函数类似，只是在函数名字前面多一个参数，参数把这个方法绑定到这个参数对应的类型上\n附加的参数称为方法的接收者\npackage geometry import \u0026#34;math\u0026#34; type Point struct{ X, Y float64 } // 普通函数 func Distance(p, q Point) float64 { return math.Hypot(q.X-p.X, q.Y-p,Y) } // Point 类型方法 func (p Point) Distance(q point) float64 { return math.Hypot(q.X-p.X, q.Y-p,Y) } go 中接收者不使用特殊名（this 或 self）；而是我们自己选择接收者名字。通常取类型名称的首字符\np := Point{1, 2} q := Point{4, 6} fmt.Println(Distance(p, q)) fmt.Println(p.Distance(q)) 上述两个 Distance 函数声明没有冲突，第一个是包级别的函数（称为 geometry.Distance）。第二个声明一个类型 Point 的方法（Point.Distance）\n表达式 p.Distance 称作选择子（selector）因为它为接收者 p 选择合适的 Distance 方法。选择子也作用于选择结构类型中的字段值，由于方法与字段来自同一个命名空间，同名的字段与方法，编译器会报错。\ngo 中的方法可以绑定到任何类型上，同一个包下的任何类型都可以声明方法，只要它的类型既不是指针类型也不是接口类型\n类型拥有的方法名必须是唯一的，但不同类型可以使用相同的方法名\n方法可以比函数更简单，在包的外部进行调用的时候，方法能狗使用更加简短的名字且省略包的名字\n指针接收者的方法\r#\r\r主调函数会复制每一个实参变量，如果函数需要更新一个变量，或者实参太大，为了避免复制整个实参，可以使用指针来传递变量的地址。这同样适用于更新接收者\nfunc (p *Point) ScaleBy(factor float64) { p.X *= factor p.Y *= factor } 方法的名字为 (*Point).ScaleBy。\n如果 Point 的任何一个方法都使用指针接收者，那么所有的 Point 方法都应该使用指针接收者\n命名类型（Point）与指向它的指针（*Point）是唯一可以出现在接收者处声明的类型。而且。为了防止混淆，不允许本身是指针的类型进行方法声明\ntype P *int func (P) f() { /*...*/ } // 编译错误，非法的接收者类型 通过提供 *Point 能够调用 (*Point).ScaleBy 方法。以下均输出 \u0026ldquo;{2, 4}\u0026rdquo;\nr := \u0026amp;Point{1, 2} r.ScaleBy(2) fmt.Println(*r) \r\rp := Point{1, 2} pptr := \u0026amp;p pptr.ScaleBy(2) fmt.Println(p) \r\rp := Point{1, 2} (\u0026amp;p).ScaleBy(2) fmt.Println(p) \r\r\r如果接收者 p 是 Point 类型的变量，但方法要求一个 *Point 接收者，可以使用简写 p.ScaleBy(2)\n实际上编译器会对变量进行 \u0026amp;p 的隐式转换。只有变量才允许这么做，包括结构体字段。不能对一个不能取地址的 Point 接收者参数调用 *Point 方法，因为无法获取临时变量的地址。\nPoint{1, 2}.ScaleBy(2) // 编译错误，不能获取 Point 类型字面量的地址 但是如果实参接收者是 *Point 类型，以 Point.Distance 的方式调用 Point 类型的方法是合法的，因为有办法从地址中获取 Point 的值；只要解析引用指向接收值的指针值即可。编译器会自动插入一个隐式的 * 操作符。下面两个函数的调用效果是一样的\npptr.Distance(q) (*pptr).Distance(q) "}),a.add({id:3,href:'/docs/code/go/go-interface/',title:"go interface",section:"Go",content:" 接口类型是对其他类型行为的概括与抽象。使用接口写出更加灵活和通用的函数，这些函数不用绑定在一个特定的类型实现上。\n go 接口独特于隐式实现。对于具体类型，无须声明实现哪些接口，只要提供接口方法。这种设计让你无须改变已有类型的实现，就可为类型创建新的接口，对于不能修改包的类型，特别有用。\n具体类型与接口类型\n具体类型：数据及操作，通过其方法来提供额外的能力。是什么，能干什么\n接口类型：一种抽象类型，仅包含方法。即能做什么。\n\r标准库中的例子\r↕\r\rfmt.Pintf和fmt.Sprintf前者把结果发送到标准输出（其实是一个文件），后者把结构以string类型返回。\n格式化是两个函数中最复杂的部分，将格式化以接口的形式抽出。（其实两个函数都封装了第三个函数fmt.Fprintf）\npackage fmt func Fprintf(w io.Writer, format string, args ...interface{}) (int, error) func Printf(format string,args ...interface{}) (int, error) { return Fprintf(os.Stdout, format, args...) } func Sprintf(format string, args ...interface{}) string { var buf bytes.Buffer Fprintf(\u0026amp;buf, format, args...) return buf.String() } \r\r\r\r类型断言\r#\r\r作用于接口上，写法类似于x.T()，x 指接口类型表达式，T 是一个类型（称为断言类型）。\n类型断言检查作为操作数的动态类型是否满足指定的断言类型\n类型断言检查一般有两种可能\n断言类型 T 是具体类型\n类型断言检查 x 的动态类型是否就是 T，检查成功，类型断言结果就是 x 的动态值，即 T 类型。\n类型断言就是用来从它的操作数中把具体类型的值提取出来的操作。检查失败，则操作崩溃\nvar w io.Writer w := os.Stdout f := w.(*os.File)	// success， f == os.Stdout c := w.(*bytes.Buffer)	// fail, 接口类型持有的是 *os.File，不是 *bytes.Buffer 断言类型 T 是接口类型\n类型断言检查 x 的动态类型是否满足 T。成功，结构仍是一个接口值，动态值并没有提取出来。接口值的类型和值部分也没有变更，只是结果的类型为接口类型 T\n即类型断言是一个接口值的表达式，从一个接口类型变为拥有另外一套方法的接口类型（通常方法数量是增多）但保留了接口值中的动态类型和动态值部分。\n如下类型断代码中，w 和 rw 都持有 os.Stdout，于是所有对应的动态类型都是 *os.File，但 w 作为 io.Writer 仅暴露了文件的 Write 方法，而 rw 还暴露了它的 Read 方法\nvar w io.Writer w = os.Stdout rw := w.(io.ReadWriter)	// success：*os.File 有 Read 和 Write 方法  w = new(ByteCounter) rw = w.(io.ReadWriter)	// fail：ByteCounter 没有 Read 方法 无论哪种类型作为断言类型，如果操作数是一个空接口值，类型断言都失败。很少需要从一个接口类型向一个要求更宽松的类型做类型断言，该宽松类型的接口方法比原类型的少，而且是子集。因为除了在操作 nill 之外的情况下，在其他情况下这种操作与赋值一致\nw = rw	// io.ReaderWriter 可以赋值给 io.Writer w = rw.(io.Writer)	// 仅当 rw == nil 时失败 我们经常无法确定一个接口值得动态类型，这时需要检测它是否是某一个特定类型。如果类型断言出现在需要两个结果得赋值表达式中，那么断言不会在失败时崩溃，而是会多返回一个布尔值来指示断言是否成功\nvar w io.Writer = os.Stdout f, ok := w.(*os.File)	// success ok, f == os.Stdout b, ok := w.(*bytes.Buffer)	// fail：!ok, b == nil 惯例，第二个返回值赋给名为 ok 的变量，如果操作失败，ok 为 false，第一个返回值为断言类型的零值\nok 返回值通常马上用来决定下一步做什么\nif f, ok := w.(*os.File); ok { // ...use f... } 当类型断言得操作数是一个变量时，有时会看见返回值得名字与操作数变量名一致，原有的值就被新的返回值掩盖了\nif w, ok := w.(*os.File); ok { // ...use w... } "}),a.add({id:4,href:'/posts/docker-cmd/',title:"docker command",section:"Blog",content:"docker 的一些子命令\nDocker 子命令分类\n   子命令分类 子命令     Docker 环境信息 info、version   容器生命周期管理 Create、exec、kill、pause、restart、rm、run、start、stop、unpause   镜像仓库命令 login、logout、pull、push、search   镜像管理 build、images、import、load、rmi、save、tag、commit   容器运维操作 attach、export、inspect、port、ps、rename、stats、top、wait、cp、diff、update   容器资源管理 volume、network   系统日志信息 events、history、logs    docker ps 命令\ndocker ps 命令可以查看容器的相关信息，默认只显示只在运行的容器的信息，\n可以查看到的信息包括\n CONTAINER ID NAMES IMAGE STATUS 容器启动后执行的 COMMAND 创建时间 CREATED 绑定的端口 PORTS  docker ps 命令最常用的功能就是查看容器的 CONTAINER ID，以便对特定容器进行操作\ndocker ps [OPTIONS] 常用的选项有 -a 和 -l。\n  -a 参数查看所有容器，包括停止的容器；\n  -l 选项只查看最新创建的容器，包括不在运行中的容器\n "}),a.add({id:5,href:'/docs/code/go/go-goroutine-channel/',title:"go goroutine channel",section:"Go",content:"Go 有两种并发编程的风格。goroutine 和 通道，以及共享内存多线程的传统模型\ngoroutine 和 通道（channel），支持通信顺序进程（Communicating Sequential Process，CSP），CSP 是一个并发的模式，在不同的执行体（goroutine）之间传递值，但是变量本身局限于单一的执行体。\n1.1 goroutine\r#\r\rGo 中，每一个并发执行的活动称为 goroutine\n一个程序启动时，只有一个 goroutine 来调用 main 函数，称为 主goroutine 。新的 goroutine 通过 go 语句进行创建。语法上，一个 go 语句是在普通函数或方法调用前加上 go 关键字前缀。\ngo 语句使函数在一个新创建的 goroutine 中调用。go 语句本身的执行立即完成\nf()	// 调用 f()，等待它返回 go f()	// 新建一个 goroutine 调用 f()，不用等待 main 函数返回时，所有的 goroutine 都暴力地直接终结，然后程序退出。除了从 main 返回或者退出程序之外，没有程序化的方法让一个 goroutine 来停止另一个，但可以通过与 goroutine 通信来要求它自己停止。\n1.2 通道\r#\r\rgoroutine 说是 Go 程序并发的执行体，通道就是它们之间的连接\n通道是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。每一个通道是一个具体类型的导管，叫作通道的元素类型。一个有 int 类型元素的通道写为chan int\n使用内置的 make 函数来创建一个通道\nch := make(chan int)	// ch 的类型是 \u0026#39;chan int\u0026#39; 像 map 一样，通道是一个使用 make 创建的数据结构的引用。当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用同一份数据结构。和其他引用类型一样，通道的零值是 nill\n同种类型的通道可以使用 == 符号进行比较。当二者都是同一份通道数据的引用时，比较值为 true，通道也可以和 nill 进行比较。\n通道有两个主要操作：发送（send）和接收（receive），两者统称为通信。send 语句从一个 goroutine 传输一个值到另一个在执行接收表达式的 goroutine。两个操作都使用 \u0026lt;- 操作符书写。发送语句中，通道和值分别在 \u0026lt;- 的左右两边。在接收表达式中，\u0026lt;- 放在通道操作数的前面。在接收表达式中，其结果未被使用也是合法的。\nch \u0026lt;- x	// 发送语句 x = \u0026lt;-ch	// 赋值语句中的接收表达式 \u0026lt;-ch	// 接收语句，丢弃结果 通道支持第三个操作：关闭（close），它设置一个标志位来指示值当前已经发送完毕，这个通道后面没有值了；关闭后的发送操作将导致宕机。在一个已经关闭的通道上进行接收操作，将获取所有已经发送的值，直到通道为空；这时任何接收操作会立即完成，同时获取到第一个通道元素类型对应的零值。\n调用内置的 close 函数来关闭通道：\nclose(ch) 使用简单的 make 调用创建的通道叫无缓冲通道（unbuffered），但 make 还可以接收第二个可选参数，一个表示通道容量的整数。如果容量是 0，make 创建一个无缓冲通道\nch = make(chan int)	// 无缓冲通道 ch = make(chan int, 0)	// 无缓冲通道 ch = make(chan int, 3)	// 容量为3的缓冲通道 1.2.1 无缓冲通道\r#\r\r无缓冲通道上的发送操作将会阻塞，直到另一个 goroutine 在对应的通道上执行接收操作，这时值传递完毕，两个 goroutine 都可以继续执行。相反，如果接收操作先执行，接收方 goroutine 将阻塞，直到另一个 goroutine 在同一个通道上发送一个值。\n使用无缓冲通道进行的通信导致发送和接收 goroutine 同步化。因此，无缓冲通道也称为同步通道。当一个值在无缓冲通道上传递时，接收值后发送方 goroutine 才能再次唤醒。\n"}),a.add({id:6,href:'/docs/code/go/go-summary/',title:"go summary",section:"Go",content:"有关 go 的一些自我总结\n1 函数\r#\r\r1.1 内置函数 make\r#\r\r创建 map\n// 创建一个从 string 到 int 的 map ages := make(map[string]int)	\r\r创建通道\n// ch 的类型是 \u0026#39;chan int\u0026#39; ch := make(chan int) \r\r\r创建 slice（指定元素类型，长度和容量）\nmake([]T, len)	// 省略容量参数，slice 的长度和容量相等 make([]T, len, cap)	// 等同于 make([]T, cap)[:len] 代码解释\r其实，make 创建了一个无名数组并返回了它的一个 slice；这个数组仅可以通过这个 slice 来访问。\n第一行代码返回的 slice 引用了整个数组。\n第二行中，slice 只引用了数组的前 len 个元素，但是它的容量是数组的长度，这为未来的 slice 元素留出空间。\r\r\r2. 比较\r#\r"}),a.add({id:7,href:'/posts/go-summary/',title:"go summary",section:"Blog",content:"有关 go 的一些自我总结\n1 函数\r#\r\r1.1 内置函数 make\r#\r\r创建 map\n// 创建一个从 string 到 int 的 map ages := make(map[string]int)	\r\r创建通道\n// ch 的类型是 \u0026#39;chan int\u0026#39; ch := make(chan int) \r\r\r创建 slice（指定元素类型，长度和容量）\nmake([]T, len)	// 省略容量参数，slice 的长度和容量相等 make([]T, len, cap)	// 等同于 make([]T, cap)[:len] 代码解释\r其实，make 创建了一个无名数组并返回了它的一个 slice；这个数组仅可以通过这个 slice 来访问。\n第一行代码返回的 slice 引用了整个数组。\n第二行中，slice 只引用了数组的前 len 个元素，但是它的容量是数组的长度，这为未来的 slice 元素留出空间。\r\r\r2. 比较\r#\r"}),a.add({id:8,href:'/posts/go-goroutine-channel/',title:"goroutine 和 通道",section:"Blog",content:"Go 有两种并发编程的风格。goroutine 和 通道，以及共享内存多线程的传统模型\ngoroutine 和 通道（channel），支持通信顺序进程（Communicating Sequential Process，CSP），CSP 是一个并发的模式，在不同的执行体（goroutine）之间传递值，但是变量本身局限于单一的执行体。\n1.1 goroutine\r#\r\rGo 中，每一个并发执行的活动称为 goroutine\n一个程序启动时，只有一个 goroutine 来调用 main 函数，称为 主goroutine 。新的 goroutine 通过 go 语句进行创建。语法上，一个 go 语句是在普通函数或方法调用前加上 go 关键字前缀。\ngo 语句使函数在一个新创建的 goroutine 中调用。go 语句本身的执行立即完成\nf()	// 调用 f()，等待它返回 go f()	// 新建一个 goroutine 调用 f()，不用等待 main 函数返回时，所有的 goroutine 都暴力地直接终结，然后程序退出。除了从 main 返回或者退出程序之外，没有程序化的方法让一个 goroutine 来停止另一个，但可以通过与 goroutine 通信来要求它自己停止。\n1.2 通道\r#\r\rgoroutine 说是 Go 程序并发的执行体，通道就是它们之间的连接\n通道是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。每一个通道是一个具体类型的导管，叫作通道的元素类型。一个有 int 类型元素的通道写为chan int\n使用内置的 make 函数来创建一个通道\nch := make(chan int)	// ch 的类型是 \u0026#39;chan int\u0026#39; 像 map 一样，通道是一个使用 make 创建的数据结构的引用。当复制或者作为参数传递到一个函数时，复制的是引用，这样调用者和被调用者都引用同一份数据结构。和其他引用类型一样，通道的零值是 nill\n同种类型的通道可以使用 == 符号进行比较。当二者都是同一份通道数据的引用时，比较值为 true，通道也可以和 nill 进行比较。\n通道有两个主要操作：发送（send）和接收（receive），两者统称为通信。send 语句从一个 goroutine 传输一个值到另一个在执行接收表达式的 goroutine。两个操作都使用 \u0026lt;- 操作符书写。发送语句中，通道和值分别在 \u0026lt;- 的左右两边。在接收表达式中，\u0026lt;- 放在通道操作数的前面。在接收表达式中，其结果未被使用也是合法的。\nch \u0026lt;- x	// 发送语句 x = \u0026lt;-ch	// 赋值语句中的接收表达式 \u0026lt;-ch	// 接收语句，丢弃结果 通道支持第三个操作：关闭（close），它设置一个标志位来指示值当前已经发送完毕，这个通道后面没有值了；关闭后的发送操作将导致宕机。在一个已经关闭的通道上进行接收操作，将获取所有已经发送的值，直到通道为空；这时任何接收操作会立即完成，同时获取到第一个通道元素类型对应的零值。\n调用内置的 close 函数来关闭通道：\nclose(ch) 使用简单的 make 调用创建的通道叫无缓冲通道（unbuffered），但 make 还可以接收第二个可选参数，一个表示通道容量的整数。如果容量是 0，make 创建一个无缓冲通道\nch = make(chan int)	// 无缓冲通道 ch = make(chan int, 0)	// 无缓冲通道 ch = make(chan int, 3)	// 容量为3的缓冲通道 1.2.1 无缓冲通道\r#\r\r无缓冲通道上的发送操作将会阻塞，直到另一个 goroutine 在对应的通道上执行接收操作，这时值传递完毕，两个 goroutine 都可以继续执行。相反，如果接收操作先执行，接收方 goroutine 将阻塞，直到另一个 goroutine 在同一个通道上发送一个值。\n使用无缓冲通道进行的通信导致发送和接收 goroutine 同步化。因此，无缓冲通道也称为同步通道。当一个值在无缓冲通道上传递时，接收值后发送方 goroutine 才能再次唤醒。\n"}),a.add({id:9,href:'/posts/go-composite-data/',title:"Go Composite Data",section:"Blog",content:"复合数据类型\r#\r\r复合数据类型是由基本数据类型以各种方式组合而构成的\n1.1 数组\r#\r\r1.2 slice\r#\r\rslice 表示一个拥有相同类型元素的可变长度的序列。slice 通常写成 []T（例如：[]string、[]int）\n其中元素的类型都是 T；它看上去像没有长度的数组类型。\n数组和 slice 紧密相关。slice 是一种轻量级的数据结构，可以用来访问数组的部分或全部的元素\n这个数组称为 slice 的底层数组。\nslice 有三个属性\n 指针：指向数组的第一个可以从 slice 中访问的元素 长度：slice 中的元素个数 容量：slice 起始元素到底层数组的最后一个元素间元素的个数\n(Go 内置函数len和 cap 用来返回 slice 的长度和容量）  一个底层数组可以对应多个 slice，这些 slice 可以引用数组的任何位置，彼此之间的元素可以重叠\n如果 slice 的引用超过了被引用对象的容量，即cap(s)，那么会导致程序宕机\n但是如果 slice 的引用超出了被引用对象的长度，即len(s)，那么最终 slice 会比原 slice 长\n1.3 map\r#\r\rGo 语言中，map 是散列表的引用，map 的类型是 map[k]V，\n键的类型 K，必须是可以通过操作符 == 来进行比较的数据类型，所以 map 可以检测某一个键是否已经存在。虽然浮点型可以进行比较，但比较浮点型的相等性不是一个好主意。尤其是在 NaN 可以是浮点型值的时候\n1.3.1 创建\r#\r\r内置函数make可以用来创建一个 map：\n// 创建一个从 string 到 int 的 map ages := make(map[string]int)	使用 map 的字面量 创建带初始化元素的字典：\nages := map[string]int{ \u0026#34;alice\u0026#34;: 31, \u0026#34;charlie\u0026#34;: 34, } \r\r等价于\nages := make(map[strint]int) map[\u0026#34;alice\u0026#34;] = 31 map[\u0026#34;charlie\u0026#34;] = 34 \r\r\r因此，新的空 map 的另一种表达式是：map[string]int{}\nmap 类型零值是 nill，即没有引用任何散列表\nvar ages map[string]int fmt.Println(ages == nill)	// true fmt.Println(len(ages) == 0)// true 向零值 map 设置元素会导致错误（设置元素之前，必须初始化 map）\nages[\u0026#34;carol\u0026#34;] = 21	// 宕机，为零值 map 中的项赋值 1.3.2 查找\r#\r\rmap 使用给定的键来查找元素，如果对应的元素不存在，就返回值类型的零值\nages[\u0026#34;alice\u0026#34;] = 32 fmt.Println(ages[\u0026#34;alice\u0026#34;])	// 32 fmt.Println(ages[\u0026#34;bob\u0026#34;])	// 0 如果想查找元素是否在 map 中，可以采取如下操作\nage, ok := ages[\u0026#34;bob\u0026#34;] if !ok {/* \u0026#34;bob\u0026#34; 不是字典中的键，age == 0 */} 两个可以合并为一个语句\nif age, 0k := ages[\u0026#34;bob\u0026#34;]; !ok {/* \u0026#34;bob\u0026#34; 不是字典中的键，age == 0 */} 通过下标访问 map 中的元素输出两个值，第二个值是一个布尔值，用来报告元素是否存在，布尔变量一般叫做 ok，尤其在 if 判断中\n1.3.3 移除\r#\r\r可以使用内置函数delete从字典中根据键移除一个元素：\ndelete(ages, \u0026#34;alice\u0026#34;)	// 移除元素 age[\u0026#34;alice\u0026#34;] 即使键不在 map 中，移除元素也是安全的\n快捷赋值方式（x+=y 和 x++）对 map 的元素同样适用\n但是 map 元素不是一个变量，不可以获取它的地址\n_ = \u0026amp;ages[\u0026#34;bob\u0026#34;]	// 编译报错，无法获取 map 元素的地址 map 中元素的迭代顺序是不固定的，不同的实现方法会使用不同的散列算法，得到不同的元素顺序，实践中，认为这种顺序是随机的。从一个元素开始到后一个元素，依次执行。可以使得程序在不同散列算法的实现下变得健壮。\n如果需要按照某种顺序来遍历 map 中的元素，必须显式地来给键排序\nimport sort var names []string for name := range ages { names = append(names, name) } sort.Strings(names) for _, name := range names { fmt.Printf(\u0026#34;%s\\t%d\\n\u0026#34;, name, ages[name]) } 因为一开始就知道 slice names 的长度，所以直接指定一个 slice 的长度会更加高效\nnames := make([]string, 0, len(ages))	// 初始化元素为空但容量足够容纳 ages map 中所有键的 slice "}),a.add({id:10,href:'/docs/code/go/go-composite-data/',title:"go composite data",section:"Go",content:"复合数据类型\r#\r\r复合数据类型是由基本数据类型以各种方式组合而构成的\n1.1 数组\r#\r\r固定长度，含有相同数据元素的序列\n 由于数组长度固定，go 中很少直接使用，slice 长度可变，使用的更多\n 数组中元素的初始值为元素类型的零值\n1.1.1 创建\r#\r\rvar a [3]int // 3 个整数的数组 数组字面量初始化数组\nvar q [3]int = [3]int{1, 2, 3} 数组字面量中， \u0026ldquo;\u0026hellip;\u0026rdquo; 出现在数组长度位置，则数组长度由初始化数组元素个数决定\nq := [...]int{1, 2, 3} fmt.Printf(\u0026#34;%T\\n\u0026#34;, q) // \u0026#34;[3]int \r\r注意点\r...\r\r数组长度是数组类型的一部分，所以 [3]int 和 [4]int 是两种不同的数据类型\r\r\r\r1.2 slice\r#\r\r相同类型元素，可变长度的序列。slice 通常写成 []T（例如：[]string、[]int） 其中元素的类型都是 T；它看上去像没有长度的数组类型。\n数组和 slice 紧密相关。slice 是一种轻量级的数据结构，可以用来访问数组的部分或全部的元素\n这个数组称为 slice 的底层数组。\nslice 有三个属性\n 指针：指向数组的第一个可以从 slice 中访问的元素 长度：slice 中的元素个数 容量：slice 起始元素到底层数组的最后一个元素间元素的个数\n(Go 内置函数len和 cap 用来返回 slice 的长度和容量）  一个底层数组可以对应多个 slice，这些 slice 可以引用数组的任何位置，彼此之间的元素可以重叠\n如果 slice 的引用超过了被引用对象的容量，即cap(s)，那么会导致程序宕机\n但是如果 slice 的引用超出了被引用对象的长度，即len(s)，那么最终 slice 会比原 slice 长\n1.3 map\r#\r\rGo 语言中，map 是散列表的引用，map 的类型是 map[k]V，\n键的类型 K，必须是可以通过操作符 == 来进行比较的数据类型，所以 map 可以检测某一个键是否已经存在。虽然浮点型可以进行比较，但比较浮点型的相等性不是一个好主意。尤其是在 NaN 可以是浮点型值的时候\n1.3.1 创建\r#\r\r内置函数make可以用来创建一个 map：\n// 创建一个从 string 到 int 的 map ages := make(map[string]int)	使用 map 的字面量 创建带初始化元素的字典：\nages := map[string]int{ \u0026#34;alice\u0026#34;: 31, \u0026#34;charlie\u0026#34;: 34, } \r\r等价于\nages := make(map[strint]int) map[\u0026#34;alice\u0026#34;] = 31 map[\u0026#34;charlie\u0026#34;] = 34 \r\r\r因此，新的空 map 的另一种表达式是：map[string]int{}\nmap 类型零值是 nill，即没有引用任何散列表\nvar ages map[string]int fmt.Println(ages == nill)	// true fmt.Println(len(ages) == 0)// true 向零值 map 设置元素会导致错误（设置元素之前，必须初始化 map）\nages[\u0026#34;carol\u0026#34;] = 21	// 宕机，为零值 map 中的项赋值 1.3.2 查找\r#\r\rmap 使用给定的键来查找元素，如果对应的元素不存在，就返回值类型的零值\nages[\u0026#34;alice\u0026#34;] = 32 fmt.Println(ages[\u0026#34;alice\u0026#34;])	// 32 fmt.Println(ages[\u0026#34;bob\u0026#34;])	// 0 如果想查找元素是否在 map 中，可以采取如下操作\nage, ok := ages[\u0026#34;bob\u0026#34;] if !ok {/* \u0026#34;bob\u0026#34; 不是字典中的键，age == 0 */} 两个可以合并为一个语句\nif age, 0k := ages[\u0026#34;bob\u0026#34;]; !ok {/* \u0026#34;bob\u0026#34; 不是字典中的键，age == 0 */} 通过下标访问 map 中的元素输出两个值，第二个值是一个布尔值，用来报告元素是否存在，布尔变量一般叫做 ok，尤其在 if 判断中\n1.3.3 移除\r#\r\r可以使用内置函数delete从字典中根据键移除一个元素：\ndelete(ages, \u0026#34;alice\u0026#34;)	// 移除元素 age[\u0026#34;alice\u0026#34;] 即使键不在 map 中，移除元素也是安全的\n快捷赋值方式（x+=y 和 x++）对 map 的元素同样适用\n但是 map 元素不是一个变量，不可以获取它的地址\n_ = \u0026amp;ages[\u0026#34;bob\u0026#34;]	// 编译报错，无法获取 map 元素的地址 map 中元素的迭代顺序是不固定的，不同的实现方法会使用不同的散列算法，得到不同的元素顺序，实践中，认为这种顺序是随机的。从一个元素开始到后一个元素，依次执行。可以使得程序在不同散列算法的实现下变得健壮。\n如果需要按照某种顺序来遍历 map 中的元素，必须显式地来给键排序\nimport sort var names []string for name := range ages { names = append(names, name) } sort.Strings(names) for _, name := range names { fmt.Printf(\u0026#34;%s\\t%d\\n\u0026#34;, name, ages[name]) } 因为一开始就知道 slice names 的长度，所以直接指定一个 slice 的长度会更加高效\nnames := make([]string, 0, len(ages))	// 初始化元素为空但容量足够容纳 ages map 中所有键的 slice "}),a.add({id:11,href:'/posts/mysql-tuning/',title:"Mysql tuning",section:"Blog",content:"Schema 与 数据类型优化\r#\r\r良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计 schema\n1.1 选择优化的数据类型\r#\r\r以下几个原则可以提供参考\n更小的通常更好\r使用最小数据类型存储数据（例如只要存0～200，tinyint unsigned 更好)\n更小的数据类型通常更快，占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。\n但需确保低估需要存储的值的范围，因为在 schema 中的多个地方增加数据类型范围是一个非常耗时和痛苦的操作。如果无法确定哪个数据类型是最好的，就选择你认为不会超过范围的最小类型\n\r\r简单就好\r简单数据类型的操作通常需要更少的 CPU 周期。\n例如，整形比字符操作代价更低，因为字符集和校对规则/排序规则是字符比较整形比较更复杂。举例：一个是使用 MySQL 内建的类型即 date,time,datatime 而不是字符串来存储日期和时间\n另一个应该用整形存储 IP 地址\n\r\r尽量避免 NULL\r通常最好指定列为 NOT NULL ，除非真的需要存储 null 值\n如果查询中包含 NULL 的列，对 MySQL 来说更难优化，可为 NULL 的列使得索引、索引统计和值比较都更复杂。\n可为 NULL 的列会使用更多的存储空间，在 MySQL 中也需要特殊处理。当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引\n通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小，所以（调优）没有必要首先在现有 schema 中查找并修改这种情况，除非这会导致问题。\n但是，如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。\n在 InnoDB 中使用单独的 bit 存储 NULL 值，所以对于稀疏数据（很多值为 NULL，只有少数行的列有非 NULL 值）有很好的空间效率。但这一点不适用于 MyISAM。\n\r\r为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等。\n接着选择具体类型。很多数据类型可以存储相同类型的数据，但会有以下区别\n 允许的精度不同 存储的长度和范围不一样 需要的物理空间（磁盘和内存空间）不同  相同大类型的不同子类型数据有时也有一些特殊的行为和属性。\n例如，DATATIME 和 TIMESTAMP 列都可以存储相同类型的数据：时间和日期，精确到秒。\n但 TIMESTAMP 只使用 DATATIME 一半的存储空间，且会根据时区变化，具有特殊的自动更新能力。\n另一方面，TIMESTAMP 允许的时间范围要小的多，有时候它的特殊能力会成为障碍。\nMySQL 为了兼容性支持很多别名，例如 INTERGER、BOOL、以及 NUMERIC。它们都只是别名，不会影响性能。如果建表时采用数据类型的别名，然后用 SHOW CREATE TABLE 检查，会发现 MySQL 报告的是基本类型，而不是别名。\n1.1.1 整数类型\r#\r\r有两种类型的数字：整数和实数，存储整数可以使用这几种类型：\n   TINYINT SMALLINT MEDIUMINT INT BIGINT     8 bit 16 bit 24 bit 32 bit 64 bit    存储的值范围从 $-2^{N-1}$ 到 $2^{N-1}-1$ 。N 是存储空间的位数\n整数类型可选 UNSIGNED 属性，表示不允许负值，这大致可以使正数的上限提高一倍。\n例如，TINYINT UNSIGNED 可以存储的范围是 0 ~ 255，TINYINT 的存储范围是 -128 ~ 127。\r 有符号和无符号类型使用相同的存储空间，并具有相同的性能，因此可以根据实际情况选择合适的类型\n你的选择决定 MySQL 是怎么在内存和磁盘中保存数据的。然而，整数计算一般使用 64 位的 BIGINT 整数，即使在 32 位环境中也是如此（一些聚合函数是例外，它们使用 DECIMAL 或 DOUBLE 进行计算）。\nMySQL 可以为整数类型指定宽度，例如 INT(11)，它不会限制值得合法范围，只是规定了 MySQL 的一些交互工具（例如命令行客户端）用来显示字符的个数。对于存储和计算来说，INT(1) 和 INT(20) 是相同的。\n 一些第三方存储引擎，比如 Infobright，有时也有自定义的存储格式和压缩方案，并不一定使用常见的 MySQL 内置引擎方式\n 4.1.2 实数类型\r#\r\r实数即带小数点的数字，然而并不只是为了存储小数部分，也可以用 DECIMA 存储比 BIGINT 大的整数\nMySQL 既支持精确类型，也支持不精确类型\n"}),a.add({id:12,href:'/posts/spring-security/',title:"Spring Security",section:"Blog",content:"dfadsfa\n任何 Spring Web 应用本质上只是一个 servlet\nSecurity Filter 在 HTTP 请求到达 controller 之前过滤每一个传入的 HTTP 请求\n过滤链\n认识 Spring Security\r#\r\rSpring Security 提供了声明式的安全访问控制解决方案（仅支持 Spring 的应用程序），对访问权限进行认证和授权，它基于 Spring Aop 和 Servlet 过滤器，提供了安全性方面的全面解决方案。\n除常规的认证和授权外，它还提供了 ACls、LDAP、JAAS、CAS 等高级特性以满足复杂环境下的安全需求。\n1. 核心概念\r#\r\r Principle：代表用户的对象 Principle（User），不仅指用户，还包括一切可以用于验证的设备。 Authority：代表用户的角色 Authority（Role），每个用户都应该有一种角色，如管理员或是会员。 Permission：代表授权，复杂的应用环境需要对角色的权限进行表述。  在 Spring Security 中，Authority 和 Permission 是两个完全独立的概念，两者并没有必然的联系，它们之间需要通过配置进行关联，可以是自己定义的各种关系。\n2. 认证和授权\r#\r\r安全主要分为验证（authentication）和授权（authorization）两个部分\n1）验证（authentication）\r#\r\r验证指的是，建立系统使用者信息（principal）的过程。使用者可以是一个用户、设备、和可以在应该程序种执行某些操作的其他系统。\n用过户认证一般要求用户提供用户名和密码，系统通过校验用户名和密码的正确性来完成认证的通过或拒绝过程。\nSpring Security 支持主流的认证方式，包括 HTTP 基本认证、HTTP 表单验证、HTTP 摘要验证、OPenID 和 LDAP 等。\nSpring Security 进行验证的步骤如下：\n 用户使用用户名和密码登录 过滤器（UsernamePasswordAuthenticationFilter）获取到用户名、密码、然后封装成 Authentication。 AuthenticationManager 认证 token（Authentication的实现类传递）。 AuthenticationManager 认证成功，返回一个封装了用户权限信息的 Authentication 对象，用户的上下文信息（角色列表等）。 Authentication 对象赋值给当前的 SecurityContext，建立这个用户的安全上下文（通过调用 SecurityContextHolder.getContext().setAuthentication()）。 用户进行一些收到访问控制机制保护的操作，访问控制机制会依据当前安全上下文信息检查这个操作所需的权限。  除利用提供的认证外，还可以编写自己的 Filter ，提供于那些不是基于 Spring Security 的验证系统的操作。\n2）授权（authorization）\r#\r\r在一个系统中，不同用户具有的权限是不同的。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。\n它判断某个 Principal 在应用程序中是否允许执行某个操作。在进行授权判断之前，要求其所要使用到的规则必须在验证过程中已经建立好了。\n对 Web 资源的保护，最好的办法是使用过滤器。对方法调用的保护，最好的办法是使用 AOP。\nSpring Security 在进行用户认证及授权时，也是通过各种拦截器和 AOP 来控制权限访问的，从而实现安全。\n3. 模块\r#\r\r 核心模块 — spring-security-core.jar：包含核心验证和访问控制类和接口，以及支持远程配置的基本 API 远程调用 — spring-security-remote.jar：提供与 Spring Remote 集成 网页 — spring-security-web.jar：包括网站安全的模块，提供网站认证服务和基于 URL 访问控制 配置 — spring-security-config.jar：包含安全命令空间解析代码 LDAP — spring-security-ldap.jar：LDAP 验证和配置 ACL — spring-security-acl.jar：对 ACL 访问控制表的实现 CAS — spring-security-cas.jar：对 CAS 客户端的安全实现 OpenID — spring-security-openid.jar：对 OpenID 网页验证的支持 Test — spring-security-test.jar：对 spring security 的测试的支持  核心类\r#\r\r1. SecurityContext\r#\r\rSecurityContext 中包含当前正在访问系统的用户的详细信息，它只有以下两者方法：\n getAuthentication()：获取当前经过身份验证的主体或身份验证的请求令牌 setAuthentication()：更改或删除当前已验证的主体身份验证信息  2. SecurityContextHolder\r#\r\rSecurityContextHolder 用来保存 SecurityContext。最常用的是 getContext() 方法，用来获得当前 SecurityContext\nSecurityContextHolder 中定义了一系列的静态方法，而这些静态方法的内部逻辑是通过 SecurityContextHolder 持有的 SecurityContextHolderStrategy 来实现的，如 clearContext()、getContext()、setContext()、createEmptyContext()。SecurityContextHolderStrategy 接口的关键代码如下：\npublic interface SecurityContextHolderStrategy { void clearContext(); SecurityContext getContext(); void setContext(SecurityContext context); SecurityContext createEmptyContext(); } 1) strategy 实现\r#\r\r默认使用的 strategy 就是基于 ThreadLocal 的 ThreadLocalSecurityContextHolderStrategy 来实现的\n除了上述提到的，Spring Security 还提供了 3 种类型的 strategy 来实现\n ClobalSecurityContextHolderStrategy：表示全局使用一个 SecurityContext，如 C/S 结构的客户端 InheritablThreadLocalSecurityContextHolderStrategy ：使用 InheritablThreadLocal 来存放 SecurityContext，即子线程可以使用父线程中存放的变量 ThreadLocalSecurityContextHolderStrategy：使用 ThreadLocal 来存放 SecurityContext  一般情况下，使用默认的 Strategy 即可。但是，如果改变默认的 strategy，Spring Security 提供了两者方法来改变 \u0026ldquo;StrategyName\u0026rdquo;\nSecurityContextHolder 类中有 3 种不同类型的 strategy，分别为 MODE_THREADLOCAL、MODE_INHERITABLETHREADLOCAL 和 MODE_GLOBAL，关键代码如下：\npublic static final String MODE_THREADLOCAL=\u0026#34;MODE_THREADLOCAL\u0026#34;; public static final String MODE_INHERITABLETHREADLOCAL = \u0026#34;MODE_INHERITABLETHREADLOCAL\u0026#34;; public static final String MODE_GLOBAL = \u0026#34;MODE_GLOBAL\u0026#34;; public static final String SYSTEM_PROPERTY = \u0026#34;spring.security.strategy\u0026#34;; private static String strategyName = System.getProperty(SYSTEM_PROPERTY); private static SecurtyContextStrategy strategy; MODE_THREADLOCAL 是默认的方法\n如果改变 strategy ，则有以下两种方法：\n 通过 SecurityContextHolder 的静态方法 setStrategyName(java.lanng.String strategyName) 来改变需要使用的 strategy 通过系统属性（SYSTEM_PROPERTY）进行指定，其中属性名默认为 ”spring.security.strategy“，属性值为对应 strategy 的名称  2）获取当前用户的 SecurityContext\r#\r\rSpring Security 使用一个 Authentication 对象来描述当前用户的相关信息。SecurityContextHolder 中持有的是当前用户的 SecurityContext ，而 SecurityContext 持有的是代表当前用户相关信息的 Authentication 的引用。\n这个 Authentication 对象不需要自己创建，Spring Security 会自动创建相应的 Authentication 对象，然后赋值给当前的 SecurityContext 。但是，往往需要在程序中获取用户的相关信息，比如，最常见的是获取当前登录用户的用户名。在程序的任何地方，可以通过如下方式获取到当前用户的用户名。\npublic String getCurrentUsername () { Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal(); if (principal instanceof UserDetails) return ((UserDetails) principal).getUserName(); if (principal instanceof Principal) return ((Principal) principal).getName(); return String.valueOf(principal); } getAuthentication() 会返回认证信息\ngetPrincipal() 方法返回身份信息，它是 UserDetails 对身份信息的封装\n获取当前用户的用户名，最简单的方式如下：\npublic String getCurrentUsername () { return SecurityContextHolder.getContext().getAuthentication().getName(); } 在调用 SecurityContextHolder.getContext() 获取 SecurityContext 时，如果对应的 SecurityContext 不存在，则会返回空的 SecurityContext\n3） ProviderManager\r#\r\rProviderManager 会维护一个认证的列表，以便处理不同认证方式的认证，因此系统可能会存在多种认证方式，比如手机号、用户名密码、邮箱方式\n在认证时，如果 ProviderManager 的认证结果不是 null ，则说明认成功，不再进行其他方式的认证，并且作为认证的结果保存在 SecurityContext 中，如果不存在，则输出错误信息 ProviderNotFoundException4） DaoAuthenticationProvider\r#\r\r它是 AuthenticationProvider 最常见的实现，用来获取用户提交的用户名和密码，并进行正确性比对。如果正确，则返回一个数据库中的用户信息\n在用户在前台提交了用户名和密码后，就会封装成 UsernamePasswordAuthenticationToken。然后，DaoAuthenticationProvider 根据 retireveUser 方法，交给 additionalAuthenticationChecks 方法完成 UsernamePasswordAuthenticationToken 和 UserDetails 密码的比对。如果这个方法没有抛出异常，则认为对比成功。\n比对密码需要用到 PasswordEncoder 和 SaltSource\n5） UserDetails\r#\r\rUserDetails 是 Spring Security 的用户实体类，包含用户名、密码、权限等信息。Spring Security 默认实现了内置的 User 类，供 Spring Security 安全认证使用。当然，也可以自己实现。\nUserDetails 和 Authentication 接口很类似，都拥有 username 和 authorities 。一定要区分清楚 Authentication 的 getCredentials() 与 UserDetails 中的 getPassword() 。前者是用户提交的密码凭证，不一定是正确的，或数据库不一定存在；后者是用户正确的密码，认证器要进行比对的就是两者是否相同。\nAuthentication 的 getAuthorities() 方法是由 UserDetails 的 getAuthorities() 传递而形成的。UserDetails 的用户信息是经过 AuthenticationProvider 认证之后被填充的。\nUserDetails 中提供了以下几种方法：\n Stirng getPassword()：返回验证用户密码，无法返回则显示为 null。 Stirng getUsername()：返回验证用户名，无法返回则显示为 null。 boolean isAccountNonExpired()：账户是否过期，过期无法验证。 boolean isAccountNonLocked()：指定用户是否被锁定或解锁，锁定的用户无法进行身份验证。 boolean isCredentialsNonExpired()：指定是否已过期的用户的凭证（密码），过期的凭证无法认证。 boolean isEabled()：是否被禁用，禁用的用户不能进行身份验证。  6） UserDetailsService\r#\r\r用户信息是通过 UserDetailsService 接口来加载的。该接口的唯一方法是 loadUserByUsername(String username) ，用来根据用户名加载相关信息，这个方法的返回值是 UserDetails 接口，其中包含了用户的信息，包括用户名、密码、权限、是否启用、是否被锁定、是否过期等。\n7） GrantedAuthority\r#\r\rGrantedAuthority 只定义了一个 getAuthority() 方法。该方法返回一个字符串，表示对应权限的字符串。如果对应权限不能用字符串表示，则返回 null。\nGrantedAuthority 接口通过 UserDetailsService 进行加载，然后赋予 UserDetails\nAuthentication 的 getAuthorities() 方法可以返回当前 Authentication 对象拥有的权限，其返回值是一个 GrantedAuthority 类型的数组。每一个 GrantedAuthority 对象代表赋予当前用户的一种权限。\n8） Filter\r#\r\r1 . SecurityContextPersistenceFilter\n它从 SecurityContextResponsity 中取出用户认证信息。为了提高效率，避免每次请求都要查询认证信息，他会从 Session 中取出已认证的用户信息，然后将其放入 SecurityContextHolder 中，以便其他 Filter 使用\n2. WebAsyncManagerIntergrationFilter\n集成了 SecurityContext 和 WebAsyncManager ，把 SecurityContext 设置到异步编程，使其也能获取到用户的上下文认证信息\n3. HanderWriterFilter\n它对请求的 Header 添加相应的信息\n4. CsrfFilter\n跨域请求伪造过滤器。通过客户端传过来的 token 与服务器端存储的 token 进行比较，来判断请求的合理性\n5. LogoutFilter\n匹配登出 URL 。匹配成功后，退出用户，并清除认证信息\n6. UsernamePasswordAuthenticationFilter\n登录认证过滤器，默认是对 \u0026ldquo;/login\u0026rdquo; 的 POST 请求进行认证。该方法会调用 attemptAuthentication ，尝试获取一个 Authentication 认证对象，以保存认证信息，然后转下下一个 Filter ，最后调用 successfulAuthentication 执行认证后的事件。\n7. AnonymousAuthenticationFilter\n如果 SecurityContextHolder 中的认证信息为空，则会创建一个匿名用户到 SecurityContextHolder 中。\n8. SessionManagementFilter\n持久化登录用户的用户信息。用户信息会被保存到 Session、Cookie、或 Redis 中\n配置 Spring Security\r#\r\r1. 继承 WebSecurityConfigurerAdapter\r#\r\r通过重写抽象接口 WebSecurityConfigurerAdapter ，再加上注解 @EnableWebSecurity ，可以实现 Web 的安全配置\nWebSecurityConfigurerAdapter Config 模块一共有 3 个 builder（构造程序）\n AuthenticationManagerBuilder：认证相关 builder ，用来配置全局的认证相关的信息。它包含 AuthenticationProvider 和 UserDetailsService ，前者是认证服务器提供者，后者是用户详情查询服务 HttpSecurity：进行权限控制规则相关配置 WebSecurity：进行全局请求忽略规则配置、HTTPFirewall 配置、debug 配置、全局 SecurityFilterChain 配置  配置安全，通常要重写以下方法：\n// 通过 auth 对象的方法添加身份验证 protected void configure(AuthenticationManagerBuilder auth) throws Exception {} // 通常用于设置忽略权限的静态资源 public void configure(WebSecurity web) throws Exception {} // 通过 HTTP 对象的 authorizeRequests() 方法定义 URL 访问权限。默认为 formLogin() 提供一个简单的登录验证页面 protected void configure(HttpSecurity httpSecurity) throws Exception {} 2. 配置自定义策略\r#\r\r配置安全需要继承 WebSecurityConfigurerAdapter ，然后重写其方法\n//指定为配置类 @Configuration //指定为Spring Security配置类，如果是 WebFlux，则需要启用 @EnableWebFluxSecurity @EnableWebSecurity // 如果要启用方法安全设置，则开启此项 @EnableGloabelMethodSecurity(prePostEnabled=true) public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override public void configure(WebSecurity web) throws Exception { // 不拦截静态资源  web.ignoring().antMatchers(\u0026#34;/static/**\u0026#34;); } @Bean public PasswordEncoder PasswordEncoder() { // 使用 BCrypt 加密  return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.formLogin() .usernameParameter(\u0026#34;uname\u0026#34;) .passwordParameter(\u0026#34;pwd\u0026#34;) .loginPage(\u0026#34;/admin/login\u0026#34;) .peimitAll() .and() .authorizeRequests() .antMatchers(\u0026#34;/admin/**\u0026#34;).hasRole(\u0026#34;ADMIN\u0026#34;) // 除上面外的所有请求全部需要鉴权认证  .anyRequest().authemticated(); http.logout().permitAll(); http.rememberMe().rememberMeParameter(\u0026#34;rememberme\u0026#34;); // 处理异常，拒绝访问就重定向 403 页面  http.exceptionHandling().accessDeniedPage(\u0026#34;/403\u0026#34;); http.logout().logoutSuccessUrl(\u0026#34;/\u0026#34;); http.csrf().ignoringAntMatchers(\u0026#34;/admin/upload\u0026#34;); } 代码解释如下：\n authorizeRequest()：定义哪些 URL 需要被保护，哪些不需要被保护 antMatchers(\u0026quot;/admin/**\u0026quot;).hasRole(\u0026quot;ADMIN\u0026quot;)：定义 /admin/ 下的所有 URL 。只有拥有 admin 角色的用户才有访问权限 formLogin()：自定义用户登录验证的页面 http.csrf()：配置是否开启 CSRF 保护，还可以再开启之后指定忽略的接口  如果开启了 CSRF ，则一定在验证页面加入下面代码以传递 token 值。\n\u0026lt;head\u0026gt; \u0026lt;meta name=\u0026#34;_csrf\u0026#34; th:content=\u0026#34;${_csrf.token}\u0026#34;/\u0026gt; \u0026lt;!-- default header name is X-CSRF-TOKEN --\u0026gt; \u0026lt;mate name=\u0026#34;_csrf_header\u0026#34; th:content=\u0026#34;${_csrf.headerName}\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; 如果要提交表单，则需要在表单中添加以下代码以提交 token 值\n\u0026lt;input type=\u0026#34;hidden\u0026#34; th:name=\u0026#34;${_csrf.parameterName}\u0026#34; th:value=\u0026#34;${_csrf.token}\u0026#34;\u0026gt; http.reemberMe()：记住我功能，可以指定参数。\n使用时，添加如下代码\n\u0026lt;input class=\u0026#34;i-checks\u0026#34; type=\u0026#34;checkbox\u0026#34; name=\u0026#34;rememberme\u0026#34;\u0026gt; 记住我 配置加密方式\r#\r\r默认的加密方式是 BCrypt 。只要在安全配置类配置即可使用\n@Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder();	// 使用 BCrypt 加密 } 在业务代码中，可以用以下方式对密码进行加密：\nBCryptPasswordEncoder encoder = new BCryptPasswordEncoder(); String encodePassword = encoder.encode(password); 自定义加密规则\r#\r\r除默认的加密规则，也可以自定义加密规则\n@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(UserService()).passwordEncoder(new PasswordEncoder() { @Override public String encode(CharSequence charSequence) { return MD5Util.encode((String)charSequence); } @Override public boolean matches(CharSequence charSequence, String s) { return s.equals(MD5Util.encode((String)charSequence)); } }); } 配置多用户系统\r#\r\r一个完整的系统一般包含多种用户系统，比如后台管理系统+前端用户系统。Spring Security 默认只提供一个用户系统，所以，需要通过配置实现多用户系统\n比如，要创建一个前台会员系统，则可以通过以下步骤实现\n构建 UserDetailsService 用户信息服务接口\r#\r\r构建前端用户 UserDetailsService 类，并继承 UserDetailsService 。\npublic class UserSecurityService implements UserDetailsService { @Autowired private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String name) throws UsernameNotFoundException { User user = userRepository.findByName(name); if (user == null) { User mobileUser = userRepository.findByMobile(name); if (mobileUser == null) { User emailUser = userRepository.findByEmail(name); if (emailUser == null) { throw new UsernameNotFoundException(\u0026#34;用户名，邮箱，或者手机号不存在\u0026#34;) } else { user = userRepository.findByEmail(name); } } else { user = userRepository.findByMobile(name); } } else if (\u0026#34;locked\u0026#34;.equals(user.getStatus())) { // 被锁定，无法登录  throw newLockedException(\u0026#34;用户被锁定\u0026#34;); } return user; } } 进行安全配置\r#\r\r在继承 WebSecurityConfigurerAdapter 的 Spring Security 的配置类中，配置 UserSecurtyService 类。\n@Bean UserDetailsService UserService() { return new UserSecurityService(); } 如果加入后台管理系统，只需要重复上面步骤即可\n获取当前登录用户信息的几种方式\r#\r\r在 Thymeleaf 视图中获取\r#\r\r要在 Thymeleaf 视图中获取用户信息，可以使用 Spring Securty 的标签特性。\n在 Thymeleaf 页面中引入 Thymeleaf 的 Spring Securty 依赖\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; xmlns:sec=\u0026#34;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\u0026#34;\u0026gt; \u0026lt;!- 省略 -\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!- 匿名 -\u0026gt; \u0026lt;div sec:authorize=\u0026#34;isAnonymous()\u0026#34;\u0026gt; 未登录，单击\u0026lt;a th:href=\u0026#34;@{/home/login}\u0026#34;\u0026gt;登录\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!- 已登录 -\u0026gt; \u0026lt;div sec:authorize=\u0026#34;isAuthenticated()\u0026#34;\u0026gt; \u0026lt;p\u0026gt;已登录\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;登录名：\u0026lt;span sec:authentication=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;角色：\u0026lt;span sec:authentication=\u0026#34;principal.authorities\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;id：\u0026lt;span sec:authentication=\u0026#34;principal.id\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Username：\u0026lt;span sec:authentication=\u0026#34;principal.username\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里要注意版本的对应。如果引入 thymeleaf-extras-springsecurity 依赖依然获取不到信息，那么可能是 Thymeleaf 版本和 thymeleaf-extras-springsecurity 的版本不对，请检查在 pom.xml 文件的两个依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-springsecurity5\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 在 Controller 中获取\r#\r\r在控制器中获取用户信息有 3 种方式，见代码注释。\n@GetMapping(\u0026#34;userinfo\u0026#34;) public String getProduct(Principal principal, Authentication authentication, HttpServletRequest httpServletRequest) { /** *@Decription:1，通过 Principal 参数获取 */ String username = principal.getName(); /** *@Decription:2，通过 Authentication 参数获取 */ String username2 = authentication.getName(); /** *@Decription:3，通过 HttpServletRequest 参数获取 */ Principal httpServletRequestUserPrincipal = httpServletRequest.getUserPrincipal(); String username3 = httpServletRequestUserPrincipal.getName(); return username; } 在 Bean 种获取\r#\r\rAuthentication authentication = SecurityContextHolder.getContext().getAuthentication(); if(!authentication instanceof AnonymousAuthenticationToken) { String username = authentication.getName(); return username; } 在其他 Authentication 类也可以这样获取，比如在 UsernamePasswordAuthenticationToken 类中。\n使用以上代码获取不到，可能是以下问题：\n 要使上面的获取生效，必须在继承 WebSecurityConfigurerAdapter 的类中的 http.antMacther(\u0026quot;/*\u0026quot;) 的鉴权 URL 范围内。 没有添加 Thymeleaf 的 thymeleaf-extras-springsecurity 依赖 添加了 Spring Security 的依赖，但是版本不对，比如 Spring Security 和 Thymeleaf 的版本不对  实例，用 Spring Security 实现后台登录及权限认证功能\r#\r\r引入依赖\r#\r\r\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-thymeleaf\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-springsecurity5\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 创建权限开放的页面\r#\r\r这个页面不需要鉴权即可访问，以区别演示需要鉴权的页面\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; xmlns:sec=\u0026#34;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Spring Security 案例\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome!\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a th:href=\u0026#34;@{/home}\u0026#34;\u0026gt;会员中心\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 创建需要权限验证的页面\r#\r\r其实可以和不需要鉴权的页面一样，鉴权可以不在 HTML 页面中进行\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; xmlns:sec=\u0026#34;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\u0026#34;\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;home\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;会员中心\u0026lt;/p\u0026gt; \u0026lt;p th:inline=\u0026#34;text\u0026#34;\u0026gt;Hello \u0026lt;span sec:authentication=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;form th:action=\u0026#34;@{/logout}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登出\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用 Spring Securty5 后，可以在模板中用 \u0026lt;span sec:authentication=\u0026quot;name\u0026quot;\u0026gt;\u0026lt;/span\u0026gt; 或 [[${#httpServletRequest.remoteUser}]] 来获取用户名，登出请求将被发送到 \u0026ldquo;/logout\u0026rdquo; 。成功注销后，会将用户重定向到 \u0026ldquo;/login?logout\u0026rdquo; 。\n配置 Spring Security\r#\r\r1）配置 Spring MVC\n可以继承 WebMvcConfigurer\nimport org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //设置登录处理操作  registry.addViewController(\u0026#34;/home\u0026#34;).setViewName(\u0026#34;springsecurity/home\u0026#34;); registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;springsecurity/welcome\u0026#34;); registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;springsecurity/login\u0026#34;); } } 2）配置 Spring Security\nSpring Security 的安全配置需要继承 WebSecurityConfigurerAdapter，然后重写其方法\nimport org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; @Configuration @EnableWebSecurity//指定为Spring Security配置类 public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\u0026#34;/\u0026#34;, \u0026#34;/welcome\u0026#34;, \u0026#34;/login\u0026#34;).permitAll() .anyRequest().authenticated() .and() .formLogin().loginPage(\u0026#34;/login\u0026#34;).defaultSuccessUrl(\u0026#34;/home\u0026#34;) .and() .logout().permitAll(); } @Autowired public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication().passwordEncoder(new BCryptPasswordEncoder()) // 指定编码方式  .withUser(\u0026#34;admin\u0026#34;).password(\u0026#34;e10adc3949ba59abbe56e057f20f883e\u0026#34;) .roles(\u0026#34;USER\u0026#34;); } } 代码解释如下\n @EnableWebSecurity：集成了 Spring Security 的 Web 安全支持 WebSecurityConfig：在配置类的同时集成了 WebSecurityConfigurerAdapter ，重写了其中特定方法，用于自定义 Spring Security 配置，Spring Security 的工作量都集中在该配置中 configure(HttpSecurity)：定义了哪些 URL 路径应该被拦截 configureClobal(AuthenticationManagerBuilder)：在内存中配置一个用户，admin/123456，这个用户拥有 User 角色  创建登录页面\r#\r\r登录页面要特别注意是否开启了 CSRF 功能。如果开启了，则需要提供 token 信息。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34; xmlns:sec=\u0026#34;http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\u0026#34;\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Spring Security Example \u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div th:if=\u0026#34;${param.error}\u0026#34;\u0026gt; 无效的用户名或者密码 \u0026lt;/div\u0026gt; \u0026lt;div th:if=\u0026#34;${param.logout}\u0026#34;\u0026gt; 你已经登出 \u0026lt;/div\u0026gt; \u0026lt;form th:action=\u0026#34;@{/login}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;div\u0026gt;\u0026lt;label\u0026gt; 用户名 : \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;/\u0026gt; \u0026lt;/label\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;label\u0026gt; 密码: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;/\u0026gt; \u0026lt;/label\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登录\u0026#34;/\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 权限控制方式\r#\r\rSpring EL 表达式\r#\r\rSpring Security 支持在定义 URL 访问或方法访问权限时使用 Spring EL 表达式。根据表达式返回的值（true 或 false）来授权或拒绝对应的权限。Spring Security 可用表达式对象的基类是 SecurityExpressionRoot，它提供了通用的内置表达式，见下表\n   表达式 描述     hasRole([role]) 当前用户是否拥有指定角色   hasAnyRole([role1, role2]) 多个角色以逗号进行分隔的字符串，如果当前用户拥有指定角色中的任意一个，则返回 true   hasAuthority([auth]) 等同于 hasRole   hasAnyAuthority([auth1, auth2]) 等同于 hasAnyRole   Principle 代表当前用户的 principle 对象   authentication 直接从 SecurityContext 获取当前 Authentication 对象   permitAll 总是返回 true，表示允许所有的   denyAll 总是返回 false，表示拒绝所有的   isAnonymous() 当前用户是否是一个匿名用户   isRememberMe() 表示当前用户是否是通过 Remember-Me 自动登录的   isAuthenticated() 表示当前用户是否已经登录认证成功了   isFullAuthenticated() 如果当前用户既不是匿名用户，又不是通过 Remember-Me 自动登录的，则返回 true    在视图模板文件中，可以通过表达式控制显示权限\n\u0026lt;p sec:authorize=\u0026#34;hasRole(\u0026#39;ROLE_ADMIN\u0026#39;)\u0026#34;\u0026gt;管理员\u0026lt;/p\u0026gt; \u0026lt;p sec:authorize=\u0026#34;hasRole(\u0026#39;ROLE_USER\u0026#39;)\u0026#34;\u0026gt;普通用户\u0026lt;/p\u0026gt; 在 WebSecurityConfig 中添加两个内存用户用于测试，角色分别是 ADMIN、USER\n.withUser(\u0026#34;admin\u0026#34;).password(\u0026#34;123456\u0026#34;).roles(\u0026#34;ADMIN\u0026#34;) .and().withUser(\u0026#34;user\u0026#34;).password(\u0026#34;123456\u0026#34;).roles(\u0026#34;USER\u0026#34;); 用户 admin 登录，则显示 管理员\n用户 user 登录，则显示 普通用户\n然后，在 WebSecurityConfig 中加入如下的 URL 权限配置\n.andMatchers(\u0026#34;/home\u0026#34;).hasRole(\u0026#34;ADMIN\u0026#34;) 这时，当用户访问 \u0026ldquo;home\u0026rdquo; 页面时能正常访问，而用 \u0026ldquo;user\u0026rdquo; 用户访问时则会提示 \u0026ldquo;403 禁止访问\u0026rdquo; 。因为，这段代码配置使这个页面访问必须具备ADMIN（管理员）角色，这是通过 URL 控制权限的方法\n通过表达式控制 URL 权限\r#\r\r如果要限定某类用户访问某个 URL ，则可以通过 Spring Security 提供的基于 URL 的权限控制来实现\nSpring Security 提供的保护 URL 的方法是重写 configure(HttpSecurity http) 的方法，HttpSecurity 提供的方法见下表\n   方法名 用途     access(String attribute) SpringEL 表达式结果为 true 时可访问   anonymous() 匿名可访问   denyAll() 用户不可访问   fullAuthenticated() 用户完全认证通过（非 remember me 下的自动登录）   hasAnyAuthority(String \u0026hellip;) 参数中任意权限可访问   hasAnyRole(String \u0026hellip;) 参数中任意角色可访问   hasAuthority(String) 某一权限的用户可访问   hasRole(String role) 某一角色的用户可访问   permitAll() 所有用户可访问   rememberMe() 允许通过 remember me 登录的用户访问   authenticated() 用户登录后可访问   hasIpAddress(String ipaddressException) 用户来自参数中的 IP 可访问    还需要额外注意几下几点\n authenticated()：保护 URL ，需要用户登录。如：anyRequest().authenticated() 代表其他未配置的页面都已经授权 permitAll()：指定某些 URL 不进行保护。一般针对静态资源文件和注册等未授权情况下需要访问的页面 hasRole(String role)：限制单个角色访问。在 Spring Security 中，角色是被默认增加 \u0026ldquo;ROLE_\u0026rdquo; 前缀的，所以角色 ADMIN 代表 ROLE_ADMIN hasAnyRole(String... roles)：允许多个角色访问。这和 Spring Boot1.x 版本有所不同 access(String attribute)：该方法可以创建复杂的限制，比如可以增加 RBAC 的权限表达式 hasIpAddress(String ipaddressException)：用于限制 IP 地址或子网  具体用法见下代码\n@Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\u0026#34;/static\u0026#34;, \u0026#34;/register\u0026#34;).permitAll() .antMatchers(\u0026#34;/user/**\u0026#34;).hasAnyRole(\u0026#34;USER\u0026#34;, \u0026#34;ADMIN\u0026#34;) // 代表 \u0026#34;/admin\u0026#34; 下的所有 URL 只允许 IP 为 \u0026#34;100.100.100.100\u0026#34; 且用户角色是 \u0026#34;ADMIN\u0026#34; 的用户访问  .antMatchers(\u0026#34;/admin/**\u0026#34;).access(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;) and hasIpAddress(\u0026#39;100.100.100.100\u0026#39;)\u0026#34;) // 其他未配置的页面都已经授权  .anyRequest().authenticated() } 通过表达式控制方法权限\r#\r\r要想在方法上使用权限控制，则需要使用启用方法安全设置的注解 @EnableGlobalMethodSecurity() 。它是默认是禁用的，需要在继承 WebSecurityConfigureAdapter 的类上加注解来启用，还需要配置启用的类型，它支持开启如下三种类型\n @EnableGlobalMethodSecurity(jsr250Enabled = true)：开启 JSR-250 @EnableGlobalMethodSecurity(prePostEnabled = true)：开启 prePostEnabled @EnableGlobalMethodSecurity(securedEnabled = true)：开启 secured  JSR-250\r#\r\rJSR 是 Java Specification Requests 的缩写，是 Java 规提案，任何人都可以提交 JSR ，以向 Java 平台增添新的 API 和服务，JSR 是 Java 的一个重要标准\nJava 提供了很多 JSR ，比如 JSR-250、JSR-303、JSR-308。只需要记住不同的 JSR 功能定义不一样。JSR-303 主要是为数据的验证提供了一些规范的 API。这里 JSR-250 是用于提供方法安全设置的，它注意提供了注解 @RolesAllowed 。\n它提供的方法主要有如下几种\n @DenyAll：拒绝所有访问 @RolesAllowed({\u0026quot;USER\u0026quot;, \u0026quot;ADMIN\u0026quot;})：该方法只要有 USER、ADMIN 任一权限即可访问 @PermitAll：允许所有访问  prePostEnabled\r#\r\r@preAuthorize\n它在方法执行之前执行，使用方法如下\n1）限制 userId 的值是否等于 principal 中保存的当前用户的 userId ，或当前用户是否具有 ROLE_ADMIN 的权限\n@preAuthorize(\u0026#34;#userId == authentication.principal.userId or hasAuthority(\u0026#34;ADMIN\u0026#34;)\u0026#34;) 2）限制用于 ADMIN 角色才能执行\n@preAuthorize(\u0026#34;hasRole(\u0026#39;ROLE_ADMIN\u0026#39;)\u0026#34;) 3）限制用于 ADMIN 角色或 USER 角色才能执行\n@preAuthorize(\u0026#34;hasRole(\u0026#39;ROLE_USER\u0026#39;)\u0026#34; or \u0026#34;hasRole(\u0026#39;ROLE_ADMIN\u0026#39;)\u0026#34;) 4）限制只能查询 id 小于 3 的用户才能执行\n@preAuthorize(\u0026#34;#id\u0026lt;3\u0026#34;) 5）限制只能查询自己的信息，这里一定要在当前页面经过权限验证，否则会报错\n@preAuthorize(\u0026#34;principal.username.equals(#username)\u0026#34;) 限制用户名只能为 long 的用户  @preAuthorize(\u0026#34;#user.name.equals(\u0026#39;long\u0026#39;)\u0026#34;) 对于低版本的 Spring Security ，添加注解后还需要将 AuthenticationMananger 定义为 Bean\n@Bean @Override public AuthenticationMananger authenticationManangerBean() throws Exception { return super.authenticationManangerBean(); } @Autowired AuthenticationMananger authenticationMananger; @PostAuthorize\n表示在方法执行之后执行，有时需要在方法调用完后才进行权限检查。可以通过注解 @PostAuthorize 达到这一效果\n注解 @PostAuthorize 是方法调用完成后进行权限检查的，它不能控制方法是否被调用，只能在方法调用完后检查权限，来决定是否抛出 AccessDeniedException这里也可以调用方法的返回值。如果 EL 为 false ，那么该方法已经执行完了，可能会回滚。EL 变量 returnObject 表示返回的对象，如：\n@PostAuthorize(\u0026#34;returnObject.userId == authentication.principal.userId or hasPermission(returnObject, \u0026#39;ADMIN\u0026#39;)\u0026#34;); @PreFilter\n表示在方法执行之前执行。它可以调用方法的参数，然后对参数值进行过滤、处理或修改。EL 变量 filterObject 表示参数。如有多个参数，则使用 filterTarget 注释参数。方法参数必须是集合或数组\n@postFilter\n表示方法执行之后执行。而且可以调用方法的返回值，然后对返回值进行过滤、处理、或修改，并返回。EL 变量 returnObject 表示返回的对象，方法需要返回集合或数组\n如使用 @PreFilter 和 @PostFilter 时，Spring Security 将移除使对应表达式的结果为 false 的元素。\n当 Filter 标注的方法拥有多个几个类型的参数时，需要通过 filterTarget 属性指定当前是针对哪个参数进行过滤的\nsecuredEnabled\r#\r\r开启 securedEnabled 支持后，可以使用注解 @Secured 来认证用户是否有权限访问\n@Secured(\u0026#34;IS_AUTHENTICATED_ANONYMOUSLY\u0026#34;) public Account readAccount(Long id); @Secured(ROLE_TELLER) 使用 JSR-280注解\r#\r\r1）开启支持\n在安全配置类中，启用注解 EnableGlobalMethodSecurity(jsr250Enabled=true)\n2）创建 user 服务接口 UserService\npublic interface UserService { public String addUser(); public String updateUser() ; public String deleteUser() ; } 3）实现 user 服务接口\n@Service public class UserServiceImpl implements UserService { @Override public String addUser() { System.out.println(\u0026#34;addUser\u0026#34;); return null; } @Override @RolesAllowed({\u0026#34;ROLE_USER\u0026#34;,\u0026#34;ROLE_ADMIN\u0026#34;}) public String updateUser() { System.out.println(\u0026#34;updateUser\u0026#34;); return null; } @Override @RolesAllowed(\u0026#34;ROLE_ADMIN\u0026#34;) public String deleteUser() { System.out.println(\u0026#34;delete\u0026#34;); return null; } } 4）编写控制器\n@RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private UserService userService; @GetMapping(\u0026#34;/addUser\u0026#34;) public void addUser() { userService.addUser(); } @GetMapping(\u0026#34;/updateUser\u0026#34;) public void updateUser() { userService.updateUser(); } @GetMapping(\u0026#34;/delete\u0026#34;) public void delete() { userService.deleteUser(); } } 5）测试\n启动项目，访问 \u0026ldquo;/user/addUser\u0026rdquo;，则控制台输出\naddUser 访问 \u0026ldquo;/user/delete\u0026rdquo; 和 \u0026ldquo;/user/updateUser\u0026rdquo;，则会提示没有权限：\nThere was an unexpectd error(type=Forbidden, status=403) Access Denied 实现 RBAC 权限模型\r#\r\rRBAC 模型简化了用户和权限的关系。通过角色对用户进行分组，分组后可以很方便地进行权限分配和管理。RBAC 模型易扩展和维护，下面是具体步骤\n1）创建 RBAC 验证服务接口（用于权限检查）\npublic interface RbacService { boolean hasPermission(HttpServletRequest request, Authentication authentication); } 2）编写 RBAC 服务实现，判断 URL 是否在权限表中\n实现 RBAC 服务，步骤如下：\n1 通过诸如用户和该用户权限（权限在登录成功时已经缓存起来，当需要访问权限时，直接从缓存取出）验证该请求是否有权限，有就返回 true ，没有就返回 false，不允许访问该 URL\n2 传入 request ，可以使用 request 获取该次请求的类型\n3 根据 Restful 风格使用它来控制的权限。如请求是 POST ，则证明该请求时向服务器发送一个新建资源请求，可以使用 request.getMethod() 来获取该请求的方式\n4 配合角色所允许的权限路径进行判断和授权操作\n5 如果获取到的 Principal 对象不为空，则代表授权已经通过\n本实例不针对 HTTP 请求进行判断，只根据 URL 进行鉴权\n@Component(\u0026#34;rbacService\u0026#34;) public class RbacServiceImpl implements RbacService { private org.springframework.util.AntPathMatcher AntPathMatcher = new AntPathMatcher(); @Autowired private SysPermissionRepository permissionRepository; @Autowired private SysUserRepository sysUserRepository; @Override public boolean hasPermission(HttpServletRequest request, Authentication authentication) { Object principal = authentication.getPrincipal(); boolean hasPermission = false; /** *这里应该注入用户和该用户所拥有的权限（权限在登录成功的时候已经缓存起来，当需要访问该用户的权限是，直接从缓存取出！） *然后验证该请求是否有权限，有就返回true，否则则返回false不允许访问该Url。 *还传入了request,可以使用request获取该次请求的类型。 *根据restful风格使用它来控制我们的权限 *例如当这个请求是post请求，证明该请求是向服务器发送一个新建资源请求， *我们可以使用request.getMethod()来获取该请求的方式，然后在配合角色所允许的权限路径进行判断和授权操作！ *如果能获取到Principal对象不为空证明，授权已经通过*/ if (principal != null \u0026amp;\u0026amp; principal instanceof UserDetails) { // 登录的用户名  String userName = ((UserDetails) principal).getUsername(); //获取请求登录的url  Set\u0026lt;String\u0026gt; urls = new HashSet\u0026lt;\u0026gt;();//用户具备的系统资源集合，从数据库读取  Set\u0026lt;String\u0026gt; curds = new HashSet\u0026lt;\u0026gt;();//用户具备的系统资源集合，从数据库读取  SysUser sysUser = sysUserRepository.findByName(userName); try { for (SysRole role : sysUser.getRoles()) { for (SysPermission permission : role.getPermissions()) { urls.add(permission.getUrl()); //curds.add(permission.getPermission());  curds.add(permission.getPermission()+permission.getUrl()); } } } catch (Exception e) { e.printStackTrace(); } //urls.add(\u0026#34;/sys/user/add\u0026#34;);  for (String url : urls) { if (AntPathMatcher.match(url, request.getRequestURI())) { hasPermission = true; break; } } } return hasPermission; } } 3）配置 HttpSecurity\n在继承 WebSecurityConfigurerAdapter 的类中重写 void configure(HttpSecurity http) 方法，添加如下代码\n.antMatchers(\u0026#34;/admin/**\u0026#34;).access(\u0026#34;@rbacService.check(request.authentication)\u0026#34;) 这里注意，@rbacService 接口的名字是服务实现上定义的名字，即注解 @Component(\u0026ldquo;rbacService\u0026rdquo;) 定义的参数。具体代码如下：\n@EnableGlobalMethodSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { http.formLogin() .authorizeRequests() .antMatchers(\u0026#34;/admin\u0026#34;).permitAll() // 自定义授权策略  .antMatchers(\u0026#34;/admin/rbac\u0026#34;).access(\u0026#34;@rbacService.hasPermission(request,authentication)\u0026#34;) 4）创建实体，添加测试数据\n3 个实体，分别是用户、权限和角色实体，创建完成后需要添加数据，点击左下角 code 查看代码\n5）测试\n访问 \u0026ldquo;/admin/rbac\u0026rdquo; ，会提示无权访问，跳转到登录页面\n在登录页面输入用户名，密码登录，会提示登录成功\n访问 \u0026ldquo;/admin/rbac\u0026rdquo; ，提示访问成功\n"}),a.add({id:13,href:'/docs/example/collapsed/3rd-level/4th-level/',title:"4th Level",section:"3rd Level",content:"4th Level of Menu\r#\r\rCaesorum illa tu sentit micat vestes papyriferi\r#\r\rInde aderam facti; Theseus vis de tauri illa peream. Oculos uberaque non regisque vobis cursuque, opus venit quam vulnera. Et maiora necemque, lege modo; gestanda nitidi, vero? Dum ne pectoraque testantur.\nVenasque repulsa Samos qui, exspectatum eram animosque hinc, aut manes, Assyrii. Cupiens auctoribus pariter rubet, profana magni super nocens. Vos ius sibilat inpar turba visae iusto! Sedes ante dum superest extrema.\n"}),a.add({id:14,href:'/docs/example/collapsed/3rd-level/',title:"3rd Level",section:"Collapsed",content:"3rd Level of Menu\r#\r\rNefas discordemque domino montes numen tum humili nexilibusque exit, Iove. Quae miror esse, scelerisque Melaneus viribus. Miseri laurus. Hoc est proposita me ante aliquid, aura inponere candidioribus quidque accendit bella, sumpta. Intravit quam erat figentem hunc, motus de fontes parvo tempestate.\niscsi_virus = pitch(json_in_on(eupViral),\rnorthbridge_services_troubleshooting, personal(\rfirmware_rw.trash_rw_crm.device(interactive_gopher_personal,\rsoftware, -1), megabit, ergonomicsSoftware(cmyk_usb_panel,\rmips_whitelist_duplex, cpa)));\rif (5) {\rmanagementNetwork += dma - boolean;\rkilohertz_token = 2;\rhoneypot_affiliate_ergonomics = fiber;\r}\rmouseNorthbridge = byte(nybble_xmp_modem.horse_subnet(\ranalogThroughputService * graphicPoint, drop(daw_bit, dnsIntranet),\rgateway_ospf), repository.domain_key.mouse(serverData(fileNetwork,\rtrim_duplex_file), cellTapeDirect, token_tooltip_mashup(\rripcordingMashup)));\rmodule_it = honeypot_driver(client_cold_dvr(593902, ripping_frequency) +\rcoreLog.joystick(componentUdpLink), windows_expansion_touchscreen);\rbashGigabit.external.reality(2, server_hardware_codec.flops.ebookSampling(\rciscNavigationBacklink, table + cleanDriver), indexProtocolIsp);\r "}),a.add({id:15,href:'/docs/example/hidden/',title:"Hidden",section:"Example Site",content:"This page is hidden in menu\r#\r\rQuondam non pater est dignior ille Eurotas\r#\r\rLatent te facies\r#\r\rLorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona\r#\r\rO fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer),\rpad.property_data_programming.sectorBrowserPpga(dataMask, 37,\rrecycleRup));\rintellectualVaporwareUser += -5 * 4;\rtraceroute_key_upnp /= lag_optical(android.smb(thyristorTftp));\rsurge_host_golden = mca_compact_device(dual_dpi_opengl, 33,\rcommerce_add_ppc);\rif (lun_ipv) {\rverticalExtranet(1, thumbnail_ttl, 3);\rbar_graphics_jpeg(chipset - sector_xmp_beta);\r}\r Fronde cetera dextrae sequens pennis voce muneris\r#\r\rActa cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software;\rif (internic \u0026gt; disk) {\remoticonLockCron += 37 + bps - 4;\rwan_ansi_honeypot.cardGigaflops = artificialStorageCgi;\rsimplex -= downloadAccess;\r}\rvar volumeHardeningAndroid = pixel + tftp + onProcessorUnmount;\rsector(memory(firewire + interlaced, wired)); "}),a.add({id:16,href:'/docs/shortcodes/section/',title:"Section",section:"shortcodes",content:"Section\r#\r\rSection renders pages in section as definition list, using title and description.\nExample\r#\r\r{{\u0026lt; section \u0026gt;}} \r\rPage1\r\r\rPage 1\r#\r\r\rPage2\r\r\rPage 2\r#\r\r\r"}),a.add({id:17,href:'/docs/shortcodes/section/page1/',title:"Page1",section:"Section",content:"Page 1\r#\r\r"}),a.add({id:18,href:'/docs/shortcodes/section/page2/',title:"Page2",section:"Section",content:"Page 2\r#\r\r"}),a.add({id:19,href:'/docs/soft/go-composite-data/',title:"protobuf install",section:"Soft",content:"新版本\ngoogle protobuf-3.6.1是现在最新版本，添加了新的特性，看说明\n下载地址 https://github.com/protocolbuffers/protobuf/releases\n我下载的是protobuf-all-3.6.1.tar.gz 包\n新版本不需要执行autogen.sh脚本，直接./configure就行\ntar zvxf protobuf-all-3.6.1.tar.gz\rcd protobuf-3.6.1\r./configure –prefix=/usr/local/\rsudo make # 要编译很久\rsudo make check\rsudo make install\r 编译安装protobuf的编译器protoc\nwget https://github.com/google/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz\rtar zxvf protobuf-all-3.6.1.tar.gz\r./autogen.sh\r./configure\rmake\rmake install\r 错误处理\n1、./autogen.sh执行报错./autogen.sh: line 38: autoreconf: command not found\n安装autoconf和automake\ryum -y install gcc automake autoconf libtool make\r安装g++:\ryum install gcc gcc-c++ "})})()